# `printf_factory` — Modular and Extensible printf Implementation
## 📝 Overview

`_printf` is a custom implementation of the standard C `printf` function. It replicates much of its core functionality while supporting modular, scalable, and maintainable extensions.

This project includes:

- **Mandatory format specifiers:**
  - `%c`, `%s`, `%d`, `%i`

- **Advanced format specifiers:**
  - `%b` – Binary representation
  - `%o` – Octal
  - `%x`, `%X` – Hexadecimal (lower/upper case)
  - `%u` – Unsigned decimal
  - `%p` – Pointer address

- **Custom extensions:**
  - `%S` – Prints strings, escaping non-printable characters in hex
  - `%r` – Prints strings in reverse
  - `%R` – Applies ROT13 encryption to strings

- **Feature support:**
  - Flags: `+`, space, `0`, `-`, `#`
  - Field width and precision
  - Length modifiers: `l`, `h`, `hh`

The architecture is based on a **specifier-dependent pipeline**: each format specifier has its own handler function, managed through a dynamic dispatch table (factory model). This allows new specifiers to be added easily with minimal changes to the core.

_This modular design ensures better maintainability_
width, and precision, all managed through a centralized factory system.

## 🧠 Architecture & Flow

This project is organized around a modular architecture, where the behavior of `_printf` is **format-specifier dependent**. Each specifier can define its own processing pipeline.

### 🧵 General Pipeline

1. **Entry Point — `_printf()`**
   - Parses the format string character-by-character.
   - For each `%specifier`, it builds a `format_specifier_t` struct with parsed metadata.
   - Delegates formatting logic to `format_handler()`.

2. **Specifier Dispatch — `format_handler()`**
   - Retrieves the correct handler function from the `factory` using the specifier.
   - Calls the handler, passing the specifier struct and variadic arguments.

3. **Specifier Handler — e.g. `string_handler()`, `binary_handler()`**
   - Produces a dynamically allocated string with the formatted result.
   - May use helper utilities such as `_strdup`, `_itoa`, `_strlen`, etc.

4. **Output — `_putchar()`**
   - Prints the final string to STDOUT and returns the number of printed characters.
   - All memory used for formatting is freed properly.

### 🧬 Specifier-Dependent Behavior

Each format specifier (`%d`, `%s`, `%b`, `%r`, etc.) can define a **custom pipeline**.
For example, the `%r` (reverse string) handler will:
- Allocate memory.
- Reverse the input string manually.
- Return a new string to print.

This design allows new specifiers to be added with minimal coupling, just by registering them in `factory` and defining a handler function.

## Memory Management
_printf dynamically allocates memory for strings generated by handlers based on the format specifiers and their length modifiers. Each handler is responsible for:
Allocating sufficient memory to hold the formatted string.
Returning a pointer to the allocated string.
The standard pipeline then processes the formatted string to apply width, flags, and precision, potentially creating a new string buffer to reflect these modifications.

#### Important notes:
All dynamically allocated strings are freed after printing to avoid memory leaks.

Handlers must ensure to return NULL if allocation fails.

If the input string pointer for a %s-style specifier is NULL, it is safely replaced with the string "(null)" to avoid undefined behavior.

Undefined or missing arguments for specifiers (e.g., calling %r without an argument) can cause undefined behavior and should be avoided.

To verify memory safety, valgrind has been used extensively during development, showing no leaks or invalid reads/writes after fixes.

```
==18645== HEAP SUMMARY:
==18645==     in use at exit: 0 bytes in 0 blocks
==18645==   total heap usage: 64 allocs, 64 frees, 1,398 bytes allocated
==18645==
==18645== All heap blocks were freed -- no leaks are possible
==18645==
==18645== For lists of detected and suppressed errors, rerun with: -s
==18645== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
```

## 🔖 Table of Contents

<details>
<summary>CLICK TO ENLARGE 😇</summary>

- 📄 [Description](#description)
- 🎓 [Objectives](#objectives)
- 📋 [Flow Chart](#flowchart)
- 📥 [Installation](#instalation)
- 🏗️ [Compilation](#compilation)
- 📄 [Restrictions](#restrictions)
- ⚒️ [Feature](#feature)
- 🔨 [Tech Stack](#tech-stack)
- 📂 [Files Description](#files-description)
- 👷🏼‍♂️👷🏼‍♂️ [Authors](#authors)

</details>


## 📄 <span id="description">Description</span>

printf_factory is a modular version of the standard C printf.
It focuses on printing formatted strings, with an architecture that makes adding new specifiers and features easy.

## 🎓 <span id="objectives">Objectives</span>

- **Mandatory Features:**
  - Support for basic format specifiers:
    - `%c` – character
    - `%s` – string
    - `%d` – signed decimal integer
    - `%i` – signed integer (identical to `%d`)

- **Advanced Features:**
  - Support for additional specifiers:
    - `%b` – binary
    - `%o` – octal
    - `%x` – hexadecimal (lowercase)
	- `%X` - hexadecimal (uppercase)
    - `%p` – pointer address
    - Custom extensions (`%r`, `%S`, `%R`, etc.)

## 📋 <span id="flowchart">Flow chart</span>

```mermaid
---
config:
  layout: dagre
---
flowchart TD
    A["Start"] --> B("_printf call")
    B --> D{"Is string null"}
    D -- no --> E{"Did we cross the null terminator"}
    E -- no --> F{"Did we cross a %"}
    F -- no --> G["Write the character"]
    D -- yes --> H["Return error"]
    E -- yes --> I["Return success"]
    F -- yes --> J{"Did we find a specifier"}
    J -- yes --> K["Print result"]
    G -- looping --> E
    O["Skip next character"] -- looping --> E
    J -- no --> P["Print the specifier"]
    P --> O
    K --> O
    style A fill:#FFD600,stroke:#FFD600,color:#000000
    style D fill:#FFCDD2,stroke:#FFCDD2,color:#000000
    style E fill:#FFCDD2,stroke:#FFCDD2,color:#000000
    style F fill:#FFCDD2,stroke:#FFCDD2,color:#000000
    style G fill:#BBDEFB,stroke:#BBDEFB,color:#000000
    style H fill:#D50000,stroke:#D50000,color:#000000
    style I fill:#D50000,stroke:#D50000,color:#000000
    style J fill:#FFCDD2,stroke:#FFCDD2,color:#000000
    style K fill:#BBDEFB,stroke:#BBDEFB,color:#000000
    style O fill:#BBDEFB,stroke:#BBDEFB,color:#000000
    style P fill:#BBDEFB,stroke:#BBDEFB,color:#000000

```
##  🏗️ <span id="instalation">Instalation</span>
To install, you need to clone the repository as follows:
```
git clone https://github.com/JeremyLrs/holbertonschool-printf.git
cd holbertonschool-printf
```

To use the manual :

```
sudo apt install groff /* To install Groff */
groff -Tascii -man man_3_printf /* To use manual with groff */
```

On linux :
```
man ./man_3_printf
```

## ⚙️ <span id="compilation">Compilation</span>

You can compile the project using the provided `Makefile`.

### 🔧 Building

Run:
```bash
make
```

- This will:

	- Compile all .c source files into .o object files.

	- Generate the binary (default: _printf) — you can change the binary name in the Makefile.

	- Note: You must provide your own main.c file, or the binary will not be created.

### 🧹 Cleaning
#### To remove all compiled files, run:

```bash
make clean
```

 - This will delete the binary and all .o object files to ensure a fresh build.
## 📄 <span id="restrictions">Restrictions</span>

- The restrictions are as follows:
	- `Must follow betty standard`

	- `No more than 5 functions per file`

	- `No use of global variables`

 - Authorized functions and macros:

	- `write`
	- `malloc`
	- `free`
	- `va_start`
	- `va_end`
	- `va_copy`
	- `va_arg`



## ⚒️ <span id="feature">Features</span>

### 🔹 Basic Usage

You can use `_printf()` as a drop-in replacement for the standard `printf()` function in your C programs.

```c
#include "main.h"

int main(void)
{
    _printf("%c\n", 'A');                      // Print a character
    _printf("%s\n", "My name is Toto");       // Print a string
    _printf("%d\n", 12345);                   // Print a decimal number
    _printf("%i\n", -1);                      // Print an integer (same as %d)
    return (0);
}
```

### 🔹 Variadic Function
_printf is a variadic function, meaning it accepts a variable number of arguments.

✅ Function Prototype

```c
int _printf(const char *format, ...);
```

### 🔹 Format Specifiers
You can print various types by using format specifiers, which begin with a % character followed by a specific letter.

#### Example: Using a Format Specifier with a Variable

```c
#include "main.h"

int main(void)
{
    int age = 18;
    _printf("Toto is %d years old.\n", age);
    return (0);
}
```
Expected output:
```bash
$: Toto is 18 years old.
```

## 🔨 <span id="tech-stack">Tech stack</span>

<p align="left">
<img src="https://img.shields.io/badge/C-blue?logo=c&logoColor=white&style=for-the-badge" alt="C badge">
<img src="https://img.shields.io/badge/GITHUB-000000?logo=github&logoColor=white&style=for-the-badge" alt="GITHUB badge">
<img src="https://img.shields.io/badge/GIT-red?logo=git&logoColor=white&style=for-the-badge" alt="GIT badge">
<img src="https://img.shields.io/badge/GCC-yellow?logo=gcc&logoColor=white&style=for-the-badge" alt="GCC badge">
<img src="https://img.shields.io/badge/LINUX-000000?logo=linux&logoColor=white&style=for-the-badge" alt="LINUX badge">
</p>

## 📂 <span id="files-description">File description</span>

| **FILE**            | **DESCRIPTION**                                  |
| -----------------: | ------------------------------------------------- |
| `main.h`()| The header file contain all the prototypes functions.      |
| `_putchar.c`()| The file contain the function `_putchar` to display a character.|
| `printf.c`()| The file contain our `printf` function.|
| `get_print_function.c`()| Function to get the right function according to a given character.|
| `string_handler.c`()| Function to `print` any given string.|
| `int_handler.c`()| Function to `print` any given character.|
| `unsigned_int_handler.c`()| Function to `print` any given unsigned integer.|
| `binary_handler.c`()| Function to `print` any given integer in binary.|
| `octal_handler.c`()| Function to `print` any given integer in octal.|
| `hexa_handler.c`()| Function to `print` any given integer in lowercase and uppercase hexadecimal.|
| `README.md`()| The `README.md` file.|
| `man_3_printf`()| Manual page of our function `printf`.|

## 👷🏼‍♂️👷🏼‍♂️ <span id="authors">Authors</span>

**👷🏼‍♂️ Adel MEJRISSI**
- GitHub: [@AdelMej](https://github.com/AdelMej)
- LinkedIn: [@adel-mejrissi](https://www.linkedin.com/in/adel-mejrissi-709374172/)

**👷🏼‍♂️ Jérémy LAURENS**
- GitHub: [@JeremyLrs](https://github.com/JeremyLrs)
- LinkedIn: [@jeremylrs](www.linkedin.com/in/jeremylrs)
 LinkedIn: [@jeremylrs](www.linkedin.com/in/jeremylrs)
